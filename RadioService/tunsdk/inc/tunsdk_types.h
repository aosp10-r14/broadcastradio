/*=============================================================================
        start of file generated by pidl version 1.0.0       
=============================================================================*/

/*******************************************************************************
 * Copyright (c) 2019-2020 OpenSynergy GmbH.
 *
 * This software may not be used in any way or distributed without
 * permission. All rights reserved.
 ******************************************************************************/

/**
 *@file    tunsdk_types.h $RelUrl: trunk/inc/sdk01/tunsdk_types.h $
 *@version $LastChangedRevision: 10583 $
 *  
 *@brief This file provides all type definitions of TUNSDK.
 *
 * 
 */

#ifndef TUNSDK_TYPES_H_
#define TUNSDK_TYPES_H_

/*-----------------------------------------------------------------------------
    includes
-----------------------------------------------------------------------------*/
#include <stdint.h>

/**
 *@brief this is a type that represents one byte(!) of a 0-terminated, UTF8 encoded string
 *        this byte may or may not contain one character
 */
typedef uint8_t T_tunsdk_utf8;

/**
 *@brief type for a character (this typedef is there because of MISRA C++ Rule 3-9-2)
 */
typedef char T_tunsdk_char;

/**
 *@brief transaction ID type
 */
typedef uint8_t tunsdk_transid_t;

/**
*@brief a buffer of raw data
*/
typedef struct
{
    uint8_t* pBuffer;   /**<pointer to the raw buffer*/
    uint32_t length;    /**<indicates how much data is valid in the location pointed to by pBuffer*/ 
}Ts_tunsdk_rawBuf;

/**
 *@brief enum to provide synchronous status information 
 */
typedef enum
{
    TUNSDK_STATUS_OK = 0,               /**< Indicates the "OK" status*/
    TUNSDK_STATUS_FAIL = 1,             /**< Indicates the failed status*/
    TUNSDK_STATUS_INVALID = -1, /**< Invalid status*/
}Te_tunsdk_status;

/**
 *@brief enum to provide a(!)synchronous result information 
 */
typedef enum
{
    TUNSDK_RESULT_OK = 0,         /**<a request was executed successfully*/
    TUNSDK_RESULT_FAIL,       /**<a request failed to execute. Reasons include: invalid parameters, hardware failure, ...*/
    TUNSDK_RESULT_CANCELLED,  /**<a request was cancelled during execution. This can be because another request interrupted the current one, or because TUNSDK was stopped */
    TUNSDK_RESULT_NALLOWED,   /**<a request was rejected because it is not allowed in the current state. Most notably, this is the case when TUNSDK is not "available"*/
    TUNSDK_RESULT_NSUPPORTED, /**<a request was rejected because it is not supported by TUNSDK in its current configuration*/
}Te_tunsdk_result;

/**
*@brief enum to identify individual observers
*/
typedef enum
{
    TUNSDK_OBSERVER_ID_Availability = 534499679, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_Availability_Notification*/
    TUNSDK_OBSERVER_ID_SelectedStation = 1297111354, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_SelectedStation_Notification*/
    TUNSDK_OBSERVER_ID_AmStationList = 449262809, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_AmStationList_Notification*/
    TUNSDK_OBSERVER_ID_FmStationList = 612284405, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_FmStationList_Notification*/
    TUNSDK_OBSERVER_ID_DabStationList = 106063066, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_DabStationList_Notification*/
    TUNSDK_OBSERVER_ID_ConfiguredSettings = 769540744, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_ConfiguredSettings_Notification*/
    TUNSDK_OBSERVER_ID_TPStatus = 902376011, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_TPStatus_Notification*/
    TUNSDK_OBSERVER_ID_Announcement_Background = 1196034990, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_Announcement_Background_Notification*/
    TUNSDK_OBSERVER_ID_Announcement_Start = 2126789804, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_Announcement_Start_Notification*/
    TUNSDK_OBSERVER_ID_Announcement_End = 1949659655, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_Announcement_End_Notification*/
    TUNSDK_OBSERVER_ID_DabAudioStatus = 1442156043, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_DabAudioStatus_Notification*/
    TUNSDK_OBSERVER_ID_HdAudioStatus = 1149158964, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_HdAudioStatus_Notification*/
    TUNSDK_OBSERVER_ID_AmFmTmcChannel = 1936917775, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_AmFmTmcChannel_Notification*/
    TUNSDK_OBSERVER_ID_AmFmTmcMessage = 2035374611, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_AmFmTmcMessage_Notification*/
    TUNSDK_OBSERVER_ID_Slideshow = 869822984, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_Slideshow_Notification*/
    TUNSDK_OBSERVER_ID_DabEPG = 1385661614, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_DabEPG_Notification*/
    TUNSDK_OBSERVER_ID_PresetList = 1610436251, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_PresetList_Notification*/
    TUNSDK_OBSERVER_ID_RequireModeChange = 679264947, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_RequireModeChange_Notification*/
    TUNSDK_OBSERVER_ID_UpdateFirmwareProgress = 1668508740, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_UpdateFirmwareProgress_Notification*/
    TUNSDK_OBSERVER_ID_HdTpegData = 233690472, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_HdTpegData_Notification*/
    TUNSDK_OBSERVER_ID_HdTpegChannel = 496418863, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_HdTpegChannel_Notification*/
    TUNSDK_OBSERVER_ID_AmFmReceptionQuality = 1575119246, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_AmFmReceptionQuality_Notification*/
    TUNSDK_OBSERVER_ID_DabAudioQuality = 1314620603, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_DabAudioQuality_Notification*/
    TUNSDK_OBSERVER_ID_HdEmergencyWarningAlert = 1080376306, /**<enum to identify the observer that triggers #CTUNSDK_ClientBase::TUNSDK_On_HdEmergencyWarningAlert_Notification*/
    TUNSDK_OBSERVER_ID_ALL  = 1740723365, /**<enum to identify all observers*/
}Te_tunsdk_observer;


/**
 *@brief enum to identify the different bands
 */
typedef enum
{
    TUNSDK_BAND_FM = 0,      /**<FM band, can have HD*/
    TUNSDK_BAND_AM_MW = 1,   /**<AM band, can have HD*/
    TUNSDK_BAND_DAB = 5,     /**<DAB band*/
    TUNSDK_BAND_INVALID = -1, /**<invalid station*/
}Te_tunsdk_band;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_band_toString(Te_tunsdk_band value);


/**
 *@brief available amfm wave bands which can be used
 */
typedef enum
{
    TUNSDK_AMFM_BAND_FM = 0,      /**< FM wave band */
    TUNSDK_AMFM_BAND_AM_MW = 1,   /**< AM Medium wave band */
    TUNSDK_AMFM_BAND_INVALID = -1, /**< invalid band, is used in case if tuner is off */
}Te_tunsdk_amfm_band;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_amfm_band_toString(Te_tunsdk_amfm_band value);


/**
 *@brief Type definition of enum containing different kinds of modes the master can be in 
 */
typedef enum
{
    TUNSDK_MODE_FM = 0,         /**<FM mode*/
    TUNSDK_MODE_AM_MW = 1,      /**<AM MW mode*/
    TUNSDK_MODE_DAB = 5,        /**<DAB mode*/
    TUNSDK_MODE_BACKGROUND = 10, /**<background mode. In this mode e.g. media is in foreground. TUNSDK will provide TP support based on TP settings*/
    TUNSDK_MODE_INVALID = -1,    /**<no kind of station, do not read any data, set to other value before writing data*/
}Te_tunsdk_mode;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_mode_toString(Te_tunsdk_mode value);


/**
*@brief enum which provides the information of the current state that Radio is in 
*/
typedef enum
{
    TUNSDK_STATE_NORMAL = 0,           /**< normal/idle state, this is the state when "nothing happens" or normal tunings occur*/
    TUNSDK_STATE_STL_UPDATING_AM = 3,  /**<AM Station list is currently being updated in foreground*/
    TUNSDK_STATE_STL_UPDATING_FM = 4,  /**<FM Station list is currently being updated in foreground*/
    TUNSDK_STATE_STL_UPDATING_DAB = 5, /**<DAB Station list is currently being updated in foreground*/
    TUNSDK_STATE_SEEK = 7,             /**<Seek is in progress*/
    TUNSDK_STATE_SEEK_NONSTOP = 8,     /**<Non stop seek is in progress*/
    TUNSDK_STATE_ANNOUNCEMENT = 9,     /**<Announcement ongoing */
    TUNSDK_STATE_ENSEMBLE_SEEK = 20,    /**<DAB ensemble seek command in progress */
    TUNSDK_STATE_SERVCOMP_SEEK = 22,    /**<DAB service-component seek up command in progress */
    TUNSDK_STATE_INVALID = -1,          /**< Invalid radio state*/
}Te_tunsdk_radioState;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_radioState_toString(Te_tunsdk_radioState value);


/**
*@brief Signal status of a HD Radio station for a station that is currently not tuned. This value is an estimation of the "tunability" of a station. For the tuned station, this can be used to display a "HD icon" on the screen.
*/
typedef enum
{
    TUNSDK_HD_STATUS_ANALOG_AUDIO = 0,             /**< status to indicate that no digital reception is available on the current tuned frequency.  
                                                                                                        This status is set when directly tuning a frequency without valid multicast index*/
    TUNSDK_HD_STATUS_ACQUIRING_DIGITAL_SIGNAL = 1, /**< This status is provided while evaluating the availability of the  digital signal on tuning a SPS channel*/
    TUNSDK_HD_STATUS_ACQUIRING_DIGITAL_AUDIO = 2,  /**< This status is provided when the reception of digital signal is confirmed on a frequency and currently the 
                                                                                                        digital audio is getting acquired for providing a digital playback. Applicable for both MPS and SPS */
    TUNSDK_HD_STATUS_PLAYING_DIGITAL_AUDIO = 3,    /**< This status is set when the digital audio is acquired and digital audio is available for playback. Applicable for both MPS and SPS */
    TUNSDK_HD_STATUS_LOST_DIGITAL_SIGNAL = 4,      /**< This status is set when the digital signal is completely lost on the selected SPS channel*/
    TUNSDK_HD_STATUS_LOOSING_DIGITAL_AUDIO = 5,    /**< This status is set when the digital signal is marginally receivable on the selected SPS channel*/
    TUNSDK_HD_STATUS_BALLGAME_MODE = 6,            /**< This status is set to indicate reception of HD station in ballgame mode. Applicable only for MPS*/
    TUNSDK_HD_STATUS_INVALID = -1,                  /**< Invalid*/
}Te_tunsdk_amfmhd_signal_hd;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_amfmhd_signal_hd_toString(Te_tunsdk_amfmhd_signal_hd value);


/**
 *@brief Value to specify HD audio status. this can be used to prevent user modification of volume settings during times of no audio being output.
 */
typedef enum
{
    TUNSDK_HD_AUDIO_STATUS_ANALOG = 0,  /**<Audio status to represent analog playback(Applicable only for MPS)   */
    TUNSDK_HD_AUDIO_STATUS_DIGITAL = 1, /**<Audio status to represent digital playback(Applicable for MPS & SPS) */
    TUNSDK_HD_AUDIO_STATUS_MUTE = 2,    /**<Audio status to represent muted audio due to signal loss of a HD-only station or a HD-SPS station */
    TUNSDK_HD_AUDIO_STATUS_UNKNOWN = 3, /**<Audio status to represent unknown status of the audio during the transition period while
                                                                tuning from one station to the other station*/
    TUNSDK_HD_AUDIO_STATUS_INVALID = -1, /**<invalid audio status */
}Te_tunsdk_hd_audio_status;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_hd_audio_status_toString(Te_tunsdk_hd_audio_status value);


/**
 *@brief Value to indicate DAB station reception status for a station that is currently not tuned. This value is an estimation of the "tunability" of a station.  
 */
typedef enum
{
    TUNSDK_DAB_STL_RECEPTION_NOSIGNAL = 0, /**< No reception. Ensemble sync lost*/
    TUNSDK_DAB_STL_RECEPTION_FM = 1,       /**< FM link available only*/
    TUNSDK_DAB_STL_RECEPTION_DAB = 2,      /**< DAB reception available*/
    TUNSDK_DAB_STL_RECEPTION_UNKNOWN = 3,  /**< unknown reception status*/
    TUNSDK_DAB_STL_RECEPTION_DAB_LINK = 4, /**< DAB-DAB linking available*/
    TUNSDK_DAB_STL_RECEPTION_INVALID = -1,  /**< Invalid reception status*/
}Te_tunsdk_dab_stl_reception_status;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_dab_stl_reception_status_toString(Te_tunsdk_dab_stl_reception_status value);


/**
 *@brief enum to differentiate directions, e.g. for seek
 */
typedef enum
{
    TUNSDK_DIRECTION_UP = 0,      /**< specifies the direction UP or "towards greater values"*/
    TUNSDK_DIRECTION_DOWN = 1,    /**< specifies the direction DOWN or "towards smaller values"*/
    TUNSDK_DIRECTION_INVALID = -1, /**< Invalid enum type for direction*/
}Te_tunsdk_direction;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_direction_toString(Te_tunsdk_direction value);


/**
 *@brief enum to differentiate type of DAB seek
*/
typedef enum
{
    TUNSDK_DAB_SEEK_ENSEMBLE = 2,        /**< Seeks to the next receivable ensemble and plays the first service in that new ensemble*/
    TUNSDK_DAB_SEEK_SERVICE_PRIMARY = 3, /**< Seeks to the next primary audio service  in this ensemble, upon reaching the end of the ensemble, seek to next ensemble*/
    TUNSDK_DAB_SEEK_SERVICE_ALL = 4,     /**< Seeks to the next (primary or secondary) audio service in this ensemble, upon reaching the end of the ensemble, seek to next ensemble*/
    TUNSDK_DAB_SEEK_INVALID = -1,         /**< Invalid enum type seek type*/
}Te_tunsdk_dab_seek_type;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_dab_seek_type_toString(Te_tunsdk_dab_seek_type value);


/**
 *@brief Value to specify DAB audio status of a currently tuned staton
 */
typedef enum
{
    TUNSDK_DAB_AUDIO_MUTED = 0,      /**< No audio. Ensemble sync still ok, but bitrate too low for audio or selected service is not available*/
    TUNSDK_DAB_AUDIO_NOSIGNAL = 1,   /**< No audio. Ensemble sync lost*/
    TUNSDK_DAB_AUDIO_PLAYING = 2,    /**< DAB audio is playing*/
    TUNSDK_DAB_AUDIO_DABFM_LINK = 3, /**< FM audio is playing*/
    TUNSDK_DAB_AUDIO_UNKNOWN = 4,    /**< No information received*/
    TUNSDK_DAB_AUDIO_INVALID = -1,    /**< Invalid Audio Status */
}Te_tunsdk_dab_audio_status;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_dab_audio_status_toString(Te_tunsdk_dab_audio_status value);


/**
*@brief enum containing user settings that can be configured
*/
typedef enum
{
    TUNSDK_SETTING_FM_RDS = 0,                 /**<configure RDS switch in FM*/
    TUNSDK_SETTING_FM_AF = 1,                  /**<configure AF switch in FM*/
    TUNSDK_SETTING_FM_REG = 2,                 /**<configure REG switch in FM*/
    TUNSDK_SETTING_AM_HD = 5,                  /**<configure HD switch in AM, valid values are 1 = on, 0 = off*/
    TUNSDK_SETTING_FM_HD = 6,                  /**<configure HD switch in FM, valid values are 1 = on, 0 = off*/
    TUNSDK_SETTING_DAB_AF = 7,                 /**<configure DAB LINKING switch*/
    TUNSDK_SETTING_DAB_AF_DAB_SOFTLINKS = 8,   /**<configure whether soft links are allowed. only used in case DAB AF  */
    TUNSDK_SETTING_DAB_OTHER_ANNOUNCEMENT = 10, /**<configure "other announcement" (news, ...) in  mode*/
    TUNSDK_SETTING_TP = 12,                     /**<configure traffic monitoring and announcement handling*/
    TUNSDK_SETTING_SLIDE_SHOW = 27,             /**<enable or disable slideshow */
    TUNSDK_SETTING_EPG = 31,                    /**<enable / disable DAB EPG*/
    TUNSDK_SETTING_INVALID = -1,                /**<configure setting invalid */
}Te_tunsdk_setting;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_setting_toString(Te_tunsdk_setting value);


/**
 *@brief defines valid settings for dab_af (#TUNSDK_SETTING_DAB_AF). Note this also configures DAB->FM link behavior  
 */
typedef enum
{
    TUNSDK_SETTING_DAB_AF_OFF = 0,        /**<no af following */
    TUNSDK_SETTING_DAB_AF_DAB_ONLY = 3,   /**<follow only DAB->DAB */
    TUNSDK_SETTING_DAB_AF_FM_ONLY = 4,    /**<follow only DAB->FM */
    TUNSDK_SETTING_DAB_AF_FM_AND_DAB = 5, /**<follow freely DAB->(DAB|FM) as needed*/
    TUNSDK_SETTING_DAB_AF_INVALID = -1,    /**<invalid*/
}Te_tunsdk_setting_dab_af;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_setting_dab_af_toString(Te_tunsdk_setting_dab_af value);


/**
 *@brief defines valid settings for fm_reg (#TUNSDK_SETTING_FM_REG)
 */
typedef enum
{
    TUNSDK_SETTING_FM_REG_OFF = 0,     /**<reg setting is off: AF also between stations with different (but regionally related!) PI Code*/
    TUNSDK_SETTING_FM_REG_ON = 1,      /**<reg setting is on: AF only between station with exact the same PI */
    TUNSDK_SETTING_FM_REG_AUTO = 2,    /**<reg setting is auto: AF preferably between stations with same PI but in case of no viable alternative also to
                                                   regional related station, but only if they have the same audio contents (audio correlation is done prior to jump) */
    TUNSDK_SETTING_FM_REG_INVALID = -1, /**<invalid*/
}Te_tunsdk_setting_fm_reg;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_setting_fm_reg_toString(Te_tunsdk_setting_fm_reg value);


/**
 *@brief defines valid settings for TP (#TUNSDK_SETTING_TP)
 */
typedef enum
{
    TUNSDK_SETTING_TP_OFF = 0,        /**<TP is off, there will be no traffic announcements*/
    TUNSDK_SETTING_TP_DAB_ONLY = 3,   /**<TP from DAB only */
    TUNSDK_SETTING_TP_FM_ONLY = 4,    /**<TP from FM only */
    TUNSDK_SETTING_TP_FM_AND_DAB = 5, /**<TP from FM or DAB, depending on availability*/
    TUNSDK_SETTING_TP_INVALID = -1,    /**<invalid*/
}Te_tunsdk_setting_tp;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_setting_tp_toString(Te_tunsdk_setting_tp value);


/**
 *@brief Enum to identify different types of announcement
 */
typedef enum
{
    TUNSDK_ANNO_TYPE_FM_TA = 0,             /**<FM traffic announcement*/
    TUNSDK_ANNO_TYPE_FM_ALARM = 1,          /**<FM alarm announcement*/
    TUNSDK_ANNO_TYPE_DAB_TA = 2,            /**<DAB traffic announcement*/
    TUNSDK_ANNO_TYPE_DAB_WARNING = 3,       /**<DAB warning announcement*/
    TUNSDK_ANNO_TYPE_DAB_NEWS = 4,          /**<DAB news announcement*/
    TUNSDK_ANNO_TYPE_DAB_EVENT = 5,         /**<DAB announcement about commercial, cultural or public events */
    TUNSDK_ANNO_TYPE_DAB_SPECIAL_EVENT = 6, /**<DAB announcement about unscheduled or previously unforeseen events */
    TUNSDK_ANNO_TYPE_DAB_PROGRAM_INFO = 7,  /**<DAB announcement about current or future radio broadcasts or programmes*/
    TUNSDK_ANNO_TYPE_DAB_SPORT = 8,         /**<DAB sports announcement*/
    TUNSDK_ANNO_TYPE_DAB_FINANCIAL = 9,     /**<DAB announcement about finance or business*/
    TUNSDK_ANNO_TYPE_DAB_ALARM = 10,         /**<DAB Alarm announcement*/
    TUNSDK_ANNO_TYPE_DAB_WEATHER = 11,       /**<DAB Weather announcement*/
    TUNSDK_ANNO_TYPE_INVALID = -1,           /**<Invalid announcement type*/
}Te_tunsdk_announcement_type;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_announcement_type_toString(Te_tunsdk_announcement_type value);


/**
 *@brief enum to identify the TP status
 */
typedef enum
{
    TUNSDK_TP_STATUS_AVAILABLE = 1,   /**<TP station matching the TP setting is available on air*/
    TUNSDK_TP_STATUS_UNAVAILABLE = 2, /**<No TP station matching TP setting is available on air*/
    TUNSDK_TP_STATUS_INVALID = -1,     /**<Invalid TP status. This will also be sent if TP is off*/
}Te_tunsdk_tpStatus;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_tpStatus_toString(Te_tunsdk_tpStatus value);

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_amfmhd_metaData.
*/
struct Ts_tunsdk_amfmhd_metaData;

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in hdLongStationName
 */
#define TUNSDK_AMFMHD_METADATA_HDLONGSTATIONNAME_COUNT (256*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in songTitle
 */
#define TUNSDK_AMFMHD_METADATA_SONGTITLE_COUNT (129*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in songArtist
 */
#define TUNSDK_AMFMHD_METADATA_SONGARTIST_COUNT (129*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in songAlbum
 */
#define TUNSDK_AMFMHD_METADATA_SONGALBUM_COUNT (129*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in songGenre
 */
#define TUNSDK_AMFMHD_METADATA_SONGGENRE_COUNT (129*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in radioText
 */
#define TUNSDK_AMFMHD_METADATA_RADIOTEXT_COUNT (65*4)

/**
 *@brief AMFM meta data information
 */
struct Ts_tunsdk_amfmhd_metaData_Handle
{
    /**
     *@brief  long station Name for HD station(termed as Service display name incase of SPS stations) 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&hdLongStationName)[TUNSDK_AMFMHD_METADATA_HDLONGSTATIONNAME_COUNT]")
     */
    const T_tunsdk_utf8 (&hdLongStationName(void) const) [TUNSDK_AMFMHD_METADATA_HDLONGSTATIONNAME_COUNT];
    /**
     *@brief  the title of the currently playing song  
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&songTitle)[TUNSDK_AMFMHD_METADATA_SONGTITLE_COUNT]")
     */
    const T_tunsdk_utf8 (&songTitle(void) const) [TUNSDK_AMFMHD_METADATA_SONGTITLE_COUNT];
    /**
     *@brief  the artist of the currently playing song  
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&songArtist)[TUNSDK_AMFMHD_METADATA_SONGARTIST_COUNT]")
     */
    const T_tunsdk_utf8 (&songArtist(void) const) [TUNSDK_AMFMHD_METADATA_SONGARTIST_COUNT];
    /**
     *@brief  the album of the currently playing song  
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&songAlbum)[TUNSDK_AMFMHD_METADATA_SONGALBUM_COUNT]")
     */
    const T_tunsdk_utf8 (&songAlbum(void) const) [TUNSDK_AMFMHD_METADATA_SONGALBUM_COUNT];
    /**
     *@brief  the genre of the currently playing song  
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&songGenre)[TUNSDK_AMFMHD_METADATA_SONGGENRE_COUNT]")
     */
    const T_tunsdk_utf8 (&songGenre(void) const) [TUNSDK_AMFMHD_METADATA_SONGGENRE_COUNT];
    /**
     *@brief  Radio Text information for AMFMHD 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&radioText)[TUNSDK_AMFMHD_METADATA_RADIOTEXT_COUNT]")
     */
    const T_tunsdk_utf8 (&radioText(void) const) [TUNSDK_AMFMHD_METADATA_RADIOTEXT_COUNT];
    /**
     *@brief extract "albumArtId" out of a Ts_tunsdk_amfmhd_metaData. 
     *@returns member "albumArtId"  image for the current program/song 
     */
    uint32_t albumArtId(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_amfmhd_metaData_Handle(const Ts_tunsdk_amfmhd_metaData* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_amfmhd_metaData* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_dab_dlPlusData.
*/
struct Ts_tunsdk_dab_dlPlusData;

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in artist
 */
#define TUNSDK_DAB_DLPLUSDATA_ARTIST_COUNT (129*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in title
 */
#define TUNSDK_DAB_DLPLUSDATA_TITLE_COUNT (129*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in album
 */
#define TUNSDK_DAB_DLPLUSDATA_ALBUM_COUNT (129*4)

/**
 *@brief Dynamic Label Plus Information
 */
struct Ts_tunsdk_dab_dlPlusData_Handle
{
    /**
     *@brief artist 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&artist)[TUNSDK_DAB_DLPLUSDATA_ARTIST_COUNT]")
     */
    const T_tunsdk_utf8 (&artist(void) const) [TUNSDK_DAB_DLPLUSDATA_ARTIST_COUNT];
    /**
     *@brief title 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&title)[TUNSDK_DAB_DLPLUSDATA_TITLE_COUNT]")
     */
    const T_tunsdk_utf8 (&title(void) const) [TUNSDK_DAB_DLPLUSDATA_TITLE_COUNT];
    /**
     *@brief album 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&album)[TUNSDK_DAB_DLPLUSDATA_ALBUM_COUNT]")
     */
    const T_tunsdk_utf8 (&album(void) const) [TUNSDK_DAB_DLPLUSDATA_ALBUM_COUNT];
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_dab_dlPlusData_Handle(const Ts_tunsdk_dab_dlPlusData* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_dab_dlPlusData* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_dab_station_label.
*/
struct Ts_tunsdk_dab_station_label;

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in label
 */
#define TUNSDK_DAB_STATION_LABEL_LABEL_COUNT (17*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in shortLabel
 */
#define TUNSDK_DAB_STATION_LABEL_SHORTLABEL_COUNT (9*4)

/**
 *@brief Station label structure - for ensemble, service and service-component labels.
 */
struct Ts_tunsdk_dab_station_label_Handle
{
    /**
     *@brief  label 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&label)[TUNSDK_DAB_STATION_LABEL_LABEL_COUNT]")
     */
    const T_tunsdk_utf8 (&label(void) const) [TUNSDK_DAB_STATION_LABEL_LABEL_COUNT];
    /**
     *@brief  short label 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&shortLabel)[TUNSDK_DAB_STATION_LABEL_SHORTLABEL_COUNT]")
     */
    const T_tunsdk_utf8 (&shortLabel(void) const) [TUNSDK_DAB_STATION_LABEL_SHORTLABEL_COUNT];
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_dab_station_label_Handle(const Ts_tunsdk_dab_station_label* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_dab_station_label* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_dab_metaData.
*/
struct Ts_tunsdk_dab_metaData;

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in dls
 */
#define TUNSDK_DAB_METADATA_DLS_COUNT (129*4)

/**
 *@brief The meta-data for DAB.
 */
struct Ts_tunsdk_dab_metaData_Handle
{
    /**
     *@brief  DLS information of the station that was tuned  This information is valid for DAB mode 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&dls)[TUNSDK_DAB_METADATA_DLS_COUNT]")
     */
    const T_tunsdk_utf8 (&dls(void) const) [TUNSDK_DAB_METADATA_DLS_COUNT];
    /**
     *@brief extract "dlPlusData" out of a Ts_tunsdk_dab_metaData. 
     *@returns member "dlPlusData"  DLPlus information of the station that was tuned. This information is valid for DAB mode
     */
    Ts_tunsdk_dab_dlPlusData_Handle dlPlusData(void) const;
    /**
     *@brief extract "albumArtId" out of a Ts_tunsdk_dab_metaData. 
     *@returns member "albumArtId"  image for the current program/song 
     */
    uint32_t albumArtId(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_dab_metaData_Handle(const Ts_tunsdk_dab_metaData* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_dab_metaData* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Tu_tunsdk_metadata.
*/
union Tu_tunsdk_metadata;

/**
 *@brief contains the metadata information for amfm and dab
 */
union Tu_tunsdk_metadata_Handle
{
    /**
     *@brief extract "amfm" out of a Tu_tunsdk_metadata. 
     *@returns member "amfm" amfm meta data
     */
    Ts_tunsdk_amfmhd_metaData_Handle amfm(void) const;
    /**
     *@brief extract "dab" out of a Tu_tunsdk_metadata. 
     *@returns member "dab" dab meta data
     */
    Ts_tunsdk_dab_metaData_Handle dab(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Tu_tunsdk_metadata_Handle(const Tu_tunsdk_metadata* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Tu_tunsdk_metadata* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_metaData.
*/
struct Ts_tunsdk_metaData;

/**
 *@brief contains metadata for amfm, dab
 */
struct Ts_tunsdk_metaData_Handle
{
    /**
     *@brief extract "band" out of a Ts_tunsdk_metaData. 
     *@returns member "band" indicates the selected band, use it to decide which member of  metaData to access
     */
    Te_tunsdk_band band(void) const;
    /**
     *@brief extract "metaData" out of a Ts_tunsdk_metaData. 
     *@returns member "metaData" use metadata band to find out which data layout is valid inside metaData
     */
    Tu_tunsdk_metadata_Handle metaData(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_metaData_Handle(const Ts_tunsdk_metaData* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_metaData* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_amfmhd_tunable.
*/
struct Ts_tunsdk_amfmhd_tunable;

/**
 *@brief uniquely identifies an AMFM station with or without HD
 */
struct Ts_tunsdk_amfmhd_tunable_Handle
{
    /**
     *@brief extract "tunBand" out of a Ts_tunsdk_amfmhd_tunable. 
     *@returns member "tunBand"  the band
     */
    Te_tunsdk_amfm_band tunBand(void) const;
    /**
     *@brief extract "freqKHz" out of a Ts_tunsdk_amfmhd_tunable. 
     *@returns member "freqKHz"  the frequency
     */
    uint32_t freqKHz(void) const;
    /**
     *@brief extract "pi" out of a Ts_tunsdk_amfmhd_tunable. 
     *@returns member "pi"  the pi, or 0xFFFF0000 in case no PI
     */
    uint32_t pi(void) const;
    /**
     *@brief extract "mcast" out of a Ts_tunsdk_amfmhd_tunable. 
     *@returns member "mcast"  multicast of a HD station. 0 for MPS, 1-7 for SPS stations 
     */
    uint8_t mcast(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_amfmhd_tunable_Handle(const Ts_tunsdk_amfmhd_tunable* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_amfmhd_tunable* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_amfmhd_station_hd.
*/
struct Ts_tunsdk_amfmhd_station_hd;

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in hd_station_name
 */
#define TUNSDK_AMFMHD_STATION_HD_HD_STATION_NAME_COUNT (17*4)

/**
 *@brief AMFM HD station metadata
 */
struct Ts_tunsdk_amfmhd_station_hd_Handle
{
    /**
     *@brief extract "hdServiceIndex" out of a Ts_tunsdk_amfmhd_station_hd. 
     *@returns member "hdServiceIndex"  contains this service's index in the hd broadcast. there may be "service gaps" (e.g. 1 and 3 present only) depending on broadcaster's configuration and reception conditions
     */
    uint8_t hdServiceIndex(void) const;
    /**
     *@brief  contains the hd station name  
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&hd_station_name)[TUNSDK_AMFMHD_STATION_HD_HD_STATION_NAME_COUNT]")
     */
    const T_tunsdk_utf8 (&hd_station_name(void) const) [TUNSDK_AMFMHD_STATION_HD_HD_STATION_NAME_COUNT];
    /**
     *@brief extract "hdPty" out of a Ts_tunsdk_amfmhd_station_hd. 
     *@returns member "hdPty"  contains the HD PTY for this station 
     */
    uint8_t hdPty(void) const;
    /**
     *@brief extract "hdServicesOnFreqBits" out of a Ts_tunsdk_amfmhd_station_hd. 
     *@returns member "hdServicesOnFreqBits"  Information about which services are available on This same frequency as a bit field,     Audio programs available (bitwise xxxxxxxx - Each bit correspond to each service, from LSB MPS, SPS1,...,SPS7). e.g. 00000001 says only MPS is available
     */
    uint8_t hdServicesOnFreqBits(void) const;
    /**
     *@brief extract "allDigital" out of a Ts_tunsdk_amfmhd_station_hd. 
     *@returns member "allDigital"  true=All Digital, false=Hybrid Station
     */
    bool allDigital(void) const;
    /**
     *@brief extract "signal_rcptn" out of a Ts_tunsdk_amfmhd_station_hd. 
     *@returns member "signal_rcptn"  indicates reception status of a stations digital signal information and audio playback information
     */
    Te_tunsdk_amfmhd_signal_hd signal_rcptn(void) const;
    /**
     *@brief extract "logoId" out of a Ts_tunsdk_amfmhd_station_hd. 
     *@returns member "logoId"  logo for the current station 
     */
    uint32_t logoId(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_amfmhd_station_hd_Handle(const Ts_tunsdk_amfmhd_station_hd* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_amfmhd_station_hd* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_dab_tunable.
*/
struct Ts_tunsdk_dab_tunable;

/**
 *@brief Uniquely identifies a DAB station
 */
struct Ts_tunsdk_dab_tunable_Handle
{
    /**
     *@brief extract "sid" out of a Ts_tunsdk_dab_tunable. 
     *@returns member "sid" service id
     */
    uint32_t sid(void) const;
    /**
     *@brief extract "freqKHz" out of a Ts_tunsdk_dab_tunable. 
     *@returns member "freqKHz" the frequency in KHz
     */
    uint32_t freqKHz(void) const;
    /**
     *@brief extract "eid" out of a Ts_tunsdk_dab_tunable. 
     *@returns member "eid" ensemble id
     */
    uint16_t eid(void) const;
    /**
     *@brief extract "ecc" out of a Ts_tunsdk_dab_tunable. 
     *@returns member "ecc" extended country code
     */
    uint8_t ecc(void) const;
    /**
     *@brief extract "scids" out of a Ts_tunsdk_dab_tunable. 
     *@returns member "scids" sub component ID
     */
    uint8_t scids(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_dab_tunable_Handle(const Ts_tunsdk_dab_tunable* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_dab_tunable* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_amfmhd_station_tmc.
*/
struct Ts_tunsdk_amfmhd_station_tmc;

/**
 *@brief uniquely identifies a AMFM station carrying a TMC
 */
struct Ts_tunsdk_amfmhd_station_tmc_Handle
{
    /**
     *@brief extract "tmcPro" out of a Ts_tunsdk_amfmhd_station_tmc. 
     *@returns member "tmcPro"  indicates whether station's TMC is encrypted 
     */
    bool tmcPro(void) const;
    /**
     *@brief extract "sid" out of a Ts_tunsdk_amfmhd_station_tmc. 
     *@returns member "sid"  TMC SID 
     */
    uint8_t sid(void) const;
    /**
     *@brief extract "ltn" out of a Ts_tunsdk_amfmhd_station_tmc. 
     *@returns member "ltn"  TMC LTN 
     */
    uint8_t ltn(void) const;
    /**
     *@brief extract "ecc" out of a Ts_tunsdk_amfmhd_station_tmc. 
     *@returns member "ecc"  extended country code
     */
    uint8_t ecc(void) const;
    /**
     *@brief extract "mgs" out of a Ts_tunsdk_amfmhd_station_tmc. 
     *@returns member "mgs"  message geographical scope
     */
    uint8_t mgs(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_amfmhd_station_tmc_Handle(const Ts_tunsdk_amfmhd_station_tmc* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_amfmhd_station_tmc* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_amfmhd_station.
*/
struct Ts_tunsdk_amfmhd_station;

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in ps
 */
#define TUNSDK_AMFMHD_STATION_PS_COUNT (9*4)

/**
 *@brief AMFM station metadata including HD and TMC 
 */
struct Ts_tunsdk_amfmhd_station_Handle
{
    /**
     *@brief extract "amfmhdTunable" out of a Ts_tunsdk_amfmhd_station. 
     *@returns member "amfmhdTunable"  Structure contain tunable information 
     */
    Ts_tunsdk_amfmhd_tunable_Handle amfmhdTunable(void) const;
    /**
     *@brief  contains the PS 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&ps)[TUNSDK_AMFMHD_STATION_PS_COUNT]")
     */
    const T_tunsdk_utf8 (&ps(void) const) [TUNSDK_AMFMHD_STATION_PS_COUNT];
    /**
     *@brief extract "scrollingPs" out of a Ts_tunsdk_amfmhd_station. 
     *@returns member "scrollingPs"  indicates whether this station has a scrolling PS. Only after a scrolling has been seen by the software it can actually know 
     */
    bool scrollingPs(void) const;
    /**
     *@brief extract "presetIdx" out of a Ts_tunsdk_amfmhd_station. 
     *@returns member "presetIdx"  preset index, if 0xFF station is not in preset list 
     */
    uint8_t presetIdx(void) const;
    /**
     *@brief extract "pty" out of a Ts_tunsdk_amfmhd_station. 
     *@returns member "pty"  indicates the rds program type as last received 
     */
    uint8_t pty(void) const;
    /**
     *@brief extract "quality" out of a Ts_tunsdk_amfmhd_station. 
     *@returns member "quality"  quality of the station 
     */
    uint8_t quality(void) const;
    /**
     *@brief extract "fs" out of a Ts_tunsdk_amfmhd_station. 
     *@returns member "fs"  field strength of the station 
     */
    int8_t fs(void) const;
    /**
     *@brief extract "tp" out of a Ts_tunsdk_amfmhd_station. 
     *@returns member "tp"  indicates the TP bit of this station as it was last received 
     */
    bool tp(void) const;
    /**
     *@brief extract "ta" out of a Ts_tunsdk_amfmhd_station. 
     *@returns member "ta"  indicates the TA bit of this station as it was last received 
     */
    bool ta(void) const;
    /**
     *@brief extract "tmc" out of a Ts_tunsdk_amfmhd_station. 
     *@returns member "tmc"  indicates whether this station has rds tmc, TRUE: has TMC
     */
    bool tmc(void) const;
    /**
     *@brief extract "tmcData" out of a Ts_tunsdk_amfmhd_station. 
     *@returns member "tmcData"  tmc related data goes here in case tmc=TRUE 
     */
    Ts_tunsdk_amfmhd_station_tmc_Handle tmcData(void) const;
    /**
     *@brief extract "hd" out of a Ts_tunsdk_amfmhd_station. 
     *@returns member "hd"  this boolean flag indicates whether station is a hd station, true: is HD, false, not HD (or at least not known to be) 
     */
    bool hd(void) const;
    /**
     *@brief extract "hdData" out of a Ts_tunsdk_amfmhd_station. 
     *@returns member "hdData"  hd related station data goes here in case hd=true (Valid only when Ts_tunsdk_amfmhd_station.hd=TRUE)
     */
    Ts_tunsdk_amfmhd_station_hd_Handle hdData(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_amfmhd_station_Handle(const Ts_tunsdk_amfmhd_station* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_amfmhd_station* m_pData; /**<pointer to private data, do not access*/
    
    friend struct Ts_tunsdk_fm_station_list_Handle; /**<allow use as iterator for that list*/
    friend struct Ts_tunsdk_am_station_list_Handle; /**<allow use as iterator for that list*/
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_dab_station.
*/
struct Ts_tunsdk_dab_station;

/**
 *@brief number of bytes encoded as T_tunsdk_char in channelLabel
 */
#define TUNSDK_DAB_STATION_CHANNELLABEL_COUNT 4

/**
 *@brief Uniquely identifies a DAB station after tuning. 
 */
struct Ts_tunsdk_dab_station_Handle
{
    /**
     *@brief extract "dabTunable" out of a Ts_tunsdk_dab_station. 
     *@returns member "dabTunable"  Station-tuning information 
     */
    Ts_tunsdk_dab_tunable_Handle dabTunable(void) const;
    /**
     *@brief extract "ensembleLabel" out of a Ts_tunsdk_dab_station. 
     *@returns member "ensembleLabel"  Ensemble label 
     */
    Ts_tunsdk_dab_station_label_Handle ensembleLabel(void) const;
    /**
     *@brief extract "stationLabel" out of a Ts_tunsdk_dab_station. 
     *@returns member "stationLabel"  Service label in case of primary component. service component label in case of secondary component 
     */
    Ts_tunsdk_dab_station_label_Handle stationLabel(void) const;
    /**
     *@brief  Physical channel-name, such as "5A", "11N"  
     *@return reference to const array (declare as "const T_tunsdk_char (&channelLabel)[TUNSDK_DAB_STATION_CHANNELLABEL_COUNT]")
     */
    const T_tunsdk_char (&channelLabel(void) const) [TUNSDK_DAB_STATION_CHANNELLABEL_COUNT];
    /**
     *@brief extract "asu" out of a Ts_tunsdk_dab_station. 
     *@returns member "asu"  Announcement support flags 
     */
    uint16_t asu(void) const;
    /**
     *@brief extract "receptionStatus" out of a Ts_tunsdk_dab_station. 
     *@returns member "receptionStatus"  indicates reception status for station list stations. the actual tuning result can differ due to conditions changin permanently
     */
    Te_tunsdk_dab_stl_reception_status receptionStatus(void) const;
    /**
     *@brief extract "pty" out of a Ts_tunsdk_dab_station. 
     *@returns member "pty"  pty code 
     */
    uint8_t pty(void) const;
    /**
     *@brief extract "presetIdx" out of a Ts_tunsdk_dab_station. 
     *@returns member "presetIdx" preset index, if 0xFFFFFFFF station is not in preset list
     */
    uint8_t presetIdx(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_dab_station_Handle(const Ts_tunsdk_dab_station* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_dab_station* m_pData; /**<pointer to private data, do not access*/
    
    friend struct Ts_tunsdk_dab_station_list_Handle; /**<allow use as iterator for that list*/
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Tu_tunsdk_stationdata.
*/
union Tu_tunsdk_stationdata;

/**
 *@brief Union that contains the station data information of different components.
 */
union Tu_tunsdk_stationdata_Handle
{
    /**
     *@brief extract "amfm" out of a Tu_tunsdk_stationdata. 
     *@returns member "amfm"  AMFM data
     */
    Ts_tunsdk_amfmhd_station_Handle amfm(void) const;
    /**
     *@brief extract "dab" out of a Tu_tunsdk_stationdata. 
     *@returns member "dab"  DAB data
     */
    Ts_tunsdk_dab_station_Handle dab(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Tu_tunsdk_stationdata_Handle(const Tu_tunsdk_stationdata* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Tu_tunsdk_stationdata* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_station.
*/
struct Ts_tunsdk_station;

/**
 *@brief Structure containing station data 
 */
struct Ts_tunsdk_station_Handle
{
    /**
     *@brief extract "band" out of a Ts_tunsdk_station. 
     *@returns member "band" Indicates the selected band  
     */
    Te_tunsdk_band band(void) const;
    /**
     *@brief extract "station" out of a Ts_tunsdk_station. 
     *@returns member "station" use station band to find out which data is valid
     */
    Tu_tunsdk_stationdata_Handle station(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_station_Handle(const Ts_tunsdk_station* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_station* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_fm_station_list.
*/
struct Ts_tunsdk_fm_station_list;

/**
 *@brief number of elements of type Ts_tunsdk_amfmhd_station in stations. Please use #Ts_tunsdk_fm_station_list_Handle::stations_Length to get the number of elements at runtime (e.g. new version of the interface has different number of elements)
 */
#define TUNSDK_FM_STATION_LIST_STATIONS_COUNT 300

/**
 *@brief The station list structure for fm
 */
struct Ts_tunsdk_fm_station_list_Handle
{
    /**
     *@brief extract "nrStations" out of a Ts_tunsdk_fm_station_list. 
     *@returns member "nrStations"  Number of stations present in the station list 
     */
    uint32_t nrStations(void) const;
    /**
     *@brief extraxt the element at index i out of list stations. stations:  stations present in the station list 
     *@param i the index out of which to extract
     *@param handle memory in which to place the (handle to) element
     *@returns true in case an element is now in handle, false if the list boundary was exceeded" 
     */                 
    bool stations_ElementAt(uint32_t i, Ts_tunsdk_amfmhd_station_Handle& handle) const;
    
    /**
     *@brief get the physical dimensions of list "stations" contained in Ts_tunsdk_fm_station_list "me". See also #TUNSDK_FM_STATION_LIST_STATIONS_COUNT
     *@returns the size of the underlying array 
     */
    uint32_t stations_Length(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_fm_station_list_Handle(const Ts_tunsdk_fm_station_list* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_fm_station_list* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_am_station_list.
*/
struct Ts_tunsdk_am_station_list;

/**
 *@brief number of elements of type Ts_tunsdk_amfmhd_station in stations. Please use #Ts_tunsdk_am_station_list_Handle::stations_Length to get the number of elements at runtime (e.g. new version of the interface has different number of elements)
 */
#define TUNSDK_AM_STATION_LIST_STATIONS_COUNT 100

/**
 *@brief The station list structure for am
 */
struct Ts_tunsdk_am_station_list_Handle
{
    /**
     *@brief extract "nrStations" out of a Ts_tunsdk_am_station_list. 
     *@returns member "nrStations"  Number of stations present in the station list 
     */
    uint32_t nrStations(void) const;
    /**
     *@brief extraxt the element at index i out of list stations. stations:  stations present in the station list 
     *@param i the index out of which to extract
     *@param handle memory in which to place the (handle to) element
     *@returns true in case an element is now in handle, false if the list boundary was exceeded" 
     */                 
    bool stations_ElementAt(uint32_t i, Ts_tunsdk_amfmhd_station_Handle& handle) const;
    
    /**
     *@brief get the physical dimensions of list "stations" contained in Ts_tunsdk_am_station_list "me". See also #TUNSDK_AM_STATION_LIST_STATIONS_COUNT
     *@returns the size of the underlying array 
     */
    uint32_t stations_Length(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_am_station_list_Handle(const Ts_tunsdk_am_station_list* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_am_station_list* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_dab_station_list.
*/
struct Ts_tunsdk_dab_station_list;

/**
 *@brief number of elements of type Ts_tunsdk_dab_station in stations. Please use #Ts_tunsdk_dab_station_list_Handle::stations_Length to get the number of elements at runtime (e.g. new version of the interface has different number of elements)
 */
#define TUNSDK_DAB_STATION_LIST_STATIONS_COUNT 200

/**
 *@brief The station list structure for dab
 */
struct Ts_tunsdk_dab_station_list_Handle
{
    /**
     *@brief extract "nrStations" out of a Ts_tunsdk_dab_station_list. 
     *@returns member "nrStations"  Number of stations present in the station list 
     */
    uint32_t nrStations(void) const;
    /**
     *@brief extraxt the element at index i out of list stations. stations:  stations present in the station list 
     *@param i the index out of which to extract
     *@param handle memory in which to place the (handle to) element
     *@returns true in case an element is now in handle, false if the list boundary was exceeded" 
     */                 
    bool stations_ElementAt(uint32_t i, Ts_tunsdk_dab_station_Handle& handle) const;
    
    /**
     *@brief get the physical dimensions of list "stations" contained in Ts_tunsdk_dab_station_list "me". See also #TUNSDK_DAB_STATION_LIST_STATIONS_COUNT
     *@returns the size of the underlying array 
     */
    uint32_t stations_Length(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_dab_station_list_Handle(const Ts_tunsdk_dab_station_list* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_dab_station_list* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_settings.
*/
struct Ts_tunsdk_settings;

/**
 *@brief Structure containing all user settings of TUNSDK
 */
struct Ts_tunsdk_settings_Handle
{
    /**
     *@brief extract "fmRdsSwitch" out of a Ts_tunsdk_settings. 
     *@returns member "fmRdsSwitch" Switching to RDS is enabled or disabled  
     */
    bool fmRdsSwitch(void) const;
    /**
     *@brief extract "fmAfSwitch" out of a Ts_tunsdk_settings. 
     *@returns member "fmAfSwitch" Switching to the Alternate frequency during weak signal is enabled or disabled  
     */
    bool fmAfSwitch(void) const;
    /**
     *@brief extract "fmRegional" out of a Ts_tunsdk_settings. 
     *@returns member "fmRegional" Switching to Alternate frequency that is having the same Regional code during weak signal is enabled or disable
     */
    Te_tunsdk_setting_fm_reg fmRegional(void) const;
    /**
     *@brief extract "amHd" out of a Ts_tunsdk_settings. 
     *@returns member "amHd" Switching to the AM HD station is enabled or disabled
     */
    bool amHd(void) const;
    /**
     *@brief extract "fmHd" out of a Ts_tunsdk_settings. 
     *@returns member "fmHd" Switching to the FM HD station is enabled or disabled
     */
    bool fmHd(void) const;
    /**
     *@brief extract "dabAfSwitch" out of a Ts_tunsdk_settings. 
     *@returns member "dabAfSwitch" Switching to the Alternate frequency during weak signal is enabled or disabled
     */
    Te_tunsdk_setting_dab_af dabAfSwitch(void) const;
    /**
     *@brief extract "dabSoftlinks" out of a Ts_tunsdk_settings. 
     *@returns member "dabSoftlinks" DAB soft links are enabled or disabled 
     */
    bool dabSoftlinks(void) const;
    /**
     *@brief extract "dabOtherAnnouncements" out of a Ts_tunsdk_settings. 
     *@returns member "dabOtherAnnouncements" true if any other announcement is set
     */
    bool dabOtherAnnouncements(void) const;
    /**
     *@brief extract "mstrTp" out of a Ts_tunsdk_settings. 
     *@returns member "mstrTp" TP support
     */
    Te_tunsdk_setting_tp mstrTp(void) const;
    /**
     *@brief extract "slideshow" out of a Ts_tunsdk_settings. 
     *@returns member "slideshow" slide show
     */
    bool slideshow(void) const;
    /**
     *@brief extract "epg" out of a Ts_tunsdk_settings. 
     *@returns member "epg" electronic programme guide 
     */
    bool epg(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_settings_Handle(const Ts_tunsdk_settings* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_settings* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};


/**
 *@brief enum to identify factory reset setting type 
 */
typedef enum
{
    TUNSDK_FACTORY_RESET_ALL = 0,            /**< used to factory reset all persistent data i.e Learn/Tuner Settings/Engineering settings*/
    TUNSDK_FACTORY_RESET_RADIO_SETTINGS = 1, /**< used to factory reset Radio persistent data excluding learn memory i.e Tuner Settings/Engineering settings*/
    TUNSDK_FACTORY_RESET_LEARN_MEMORY = 2,   /**< used to factory reset learn memory*/
    TUNSDK_FACTORY_RESET_TYPE_INVALID = -1,   /**< Invalid factory reset type */
}Te_tunsdk_factory_reset_type;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_factory_reset_type_toString(Te_tunsdk_factory_reset_type value);


/**
 *@brief Known ways to start the TUNSDK
 */
typedef enum
{
    TUNSDK_START_MODE_NORMAL = 0, /**<the normal start*/
    TUNSDK_START_MODE_UPDATE = 1, /**<the start which allows the flashing of firmware into chipsets under control of TUNSDK*/
}Te_tunsdk_start_mode;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_start_mode_toString(Te_tunsdk_start_mode value);


/**
 *@brief Known ways to stop the TUNSDK
 */
typedef enum
{
    TUNSDK_STOP_MODE_NORMAL = 0, /**<the normal stop. TUNSDK persists all data and goes down, notifying unavailability*/
}Te_tunsdk_stop_mode;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_stop_mode_toString(Te_tunsdk_stop_mode value);

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_amfmTmcChannel.
*/
struct Ts_tunsdk_amfmTmcChannel;

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in ps
 */
#define TUNSDK_AMFMTMCCHANNEL_PS_COUNT (9*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in spn
 */
#define TUNSDK_AMFMTMCCHANNEL_SPN_COUNT (9*4)

/**
 *@brief amfm TMC channel that gives information about where TUNSDK is receiving TMC information from currently. 
 */
struct Ts_tunsdk_amfmTmcChannel_Handle
{
    /**
     *@brief extract "sid" out of a Ts_tunsdk_amfmTmcChannel. 
     *@returns member "sid" TMC service id of the channel 
     */
    uint8_t sid(void) const;
    /**
     *@brief extract "ltn" out of a Ts_tunsdk_amfmTmcChannel. 
     *@returns member "ltn" TMC ltn of the channel 
     */
    uint8_t ltn(void) const;
    /**
     *@brief extract "cc" out of a Ts_tunsdk_amfmTmcChannel. 
     *@returns member "cc" cc of the channel. ( == high nibble of PI) 
     */
    uint8_t cc(void) const;
    /**
     *@brief extract "ecc" out of a Ts_tunsdk_amfmTmcChannel. 
     *@returns member "ecc" extended country code. Note that ecc is often not transmitted. In that case, 0 will be provided. Note that ecc is not needed as per current TMC spec but is provided FYI
     */
    uint8_t ecc(void) const;
    /**
     *@brief  the ps of the station currently used for TMC reception. Note that it may initially not be known and empty 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&ps)[TUNSDK_AMFMTMCCHANNEL_PS_COUNT]")
     */
    const T_tunsdk_utf8 (&ps(void) const) [TUNSDK_AMFMTMCCHANNEL_PS_COUNT];
    /**
     *@brief service provider name. the service provider name can indicate who is providing the data to the broadcaster 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&spn)[TUNSDK_AMFMTMCCHANNEL_SPN_COUNT]")
     */
    const T_tunsdk_utf8 (&spn(void) const) [TUNSDK_AMFMTMCCHANNEL_SPN_COUNT];
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_amfmTmcChannel_Handle(const Ts_tunsdk_amfmTmcChannel* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_amfmTmcChannel* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_slide_time.
*/
struct Ts_tunsdk_slide_time;

/**
 * @brief trigger time  
 */
struct Ts_tunsdk_slide_time_Handle
{
    /**
     *@brief extract "isValid" out of a Ts_tunsdk_slide_time. 
     *@returns member "isValid" false means NOW (in this case ignore other parameters), true means other parameters are valid and can be used to create the time
     */
    bool isValid(void) const;
    /**
     *@brief extract "utcHours" out of a Ts_tunsdk_slide_time. 
     *@returns member "utcHours" hours in UTC
     */
    uint8_t utcHours(void) const;
    /**
     *@brief extract "utcMinutes" out of a Ts_tunsdk_slide_time. 
     *@returns member "utcMinutes" indicates the minutes 
     */
    uint8_t utcMinutes(void) const;
    /**
     *@brief extract "utcSeconds" out of a Ts_tunsdk_slide_time. 
     *@returns member "utcSeconds" seconds. seconds will have 0xFF as value in case no valid seconds value was provided from the broadcaster, it is optional as per the standard
     */
    uint8_t utcSeconds(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_slide_time_Handle(const Ts_tunsdk_slide_time* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_slide_time* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_slide.
*/
struct Ts_tunsdk_slide;

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in clickThroughURL
 */
#define TUNSDK_SLIDE_CLICKTHROUGHURL_COUNT (129*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in alternateLocURL
 */
#define TUNSDK_SLIDE_ALTERNATELOCURL_COUNT (129*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in categoryTitle
 */
#define TUNSDK_SLIDE_CATEGORYTITLE_COUNT (33*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in contentName
 */
#define TUNSDK_SLIDE_CONTENTNAME_COUNT (26*4)

/**
 * @brief image and meta data for a received slide  
 */
struct Ts_tunsdk_slide_Handle
{
    /**
     *@brief click through url for this slide 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&clickThroughURL)[TUNSDK_SLIDE_CLICKTHROUGHURL_COUNT]")
     */
    const T_tunsdk_utf8 (&clickThroughURL(void) const) [TUNSDK_SLIDE_CLICKTHROUGHURL_COUNT];
    /**
     *@brief alternative url for this slide 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&alternateLocURL)[TUNSDK_SLIDE_ALTERNATELOCURL_COUNT]")
     */
    const T_tunsdk_utf8 (&alternateLocURL(void) const) [TUNSDK_SLIDE_ALTERNATELOCURL_COUNT];
    /**
     *@brief category title  
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&categoryTitle)[TUNSDK_SLIDE_CATEGORYTITLE_COUNT]")
     */
    const T_tunsdk_utf8 (&categoryTitle(void) const) [TUNSDK_SLIDE_CATEGORYTITLE_COUNT];
    /**
     *@brief content name  
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&contentName)[TUNSDK_SLIDE_CONTENTNAME_COUNT]")
     */
    const T_tunsdk_utf8 (&contentName(void) const) [TUNSDK_SLIDE_CONTENTNAME_COUNT];
    /**
     *@brief extract "triggerTime" out of a Ts_tunsdk_slide. 
     *@returns member "triggerTime" trigger time in UTC
     */
    Ts_tunsdk_slide_time_Handle triggerTime(void) const;
    /**
     *@brief extract "expireTime" out of a Ts_tunsdk_slide. 
     *@returns member "expireTime" expire time in UTC 
     */
    Ts_tunsdk_slide_time_Handle expireTime(void) const;
    /**
     *@brief extract "categoryId" out of a Ts_tunsdk_slide. 
     *@returns member "categoryId" Category Id 
     */
    uint8_t categoryId(void) const;
    /**
     *@brief extract "slideId" out of a Ts_tunsdk_slide. 
     *@returns member "slideId" Slide Id 
     */
    uint8_t slideId(void) const;
    /**
     *@brief extract "alert" out of a Ts_tunsdk_slide. 
     *@returns member "alert" Alert parameter 
     */
    uint8_t alert(void) const;
    /**
     *@brief extract "imageId" out of a Ts_tunsdk_slide. 
     *@returns member "imageId" id to be used to retrieve the image 
     */
    uint32_t imageId(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_slide_Handle(const Ts_tunsdk_slide* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_slide* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_dab_epg.
*/
struct Ts_tunsdk_dab_epg;

/**
 *@brief number of elements of type uint8_t in scopeId
 */
#define TUNSDK_DAB_EPG_SCOPEID_COUNT 10

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in contentName
 */
#define TUNSDK_DAB_EPG_CONTENTNAME_COUNT (65*4)

/**
 *@brief number of elements of type uint8_t in rawData
 */
#define TUNSDK_DAB_EPG_RAWDATA_COUNT 81920

/**
 * @brief notification data
 */
struct Ts_tunsdk_dab_epg_Handle
{
    /**
     *@brief extract "decompressedDataSize" out of a Ts_tunsdk_dab_epg. 
     *@returns member "decompressedDataSize"  If the data is compressed this is the size of the data after decompression (only valid if compressionType!=0) 
     */
    uint32_t decompressedDataSize(void) const;
    /**
     *@brief extract "eid" out of a Ts_tunsdk_dab_epg. 
     *@returns member "eid"  Ensemble Identifier 
     */
    uint16_t eid(void) const;
    /**
     *@brief extract "contentSubType" out of a Ts_tunsdk_dab_epg. 
     *@returns member "contentSubType"  Subtype of the data
     */
    uint16_t contentSubType(void) const;
    /**
     *@brief extract "contentType" out of a Ts_tunsdk_dab_epg. 
     *@returns member "contentType"  Type of the data
     */
    uint8_t contentType(void) const;
    /**
     *@brief extract "profileSubset" out of a Ts_tunsdk_dab_epg. 
     *@returns member "profileSubset"  identifies the profile of the object
     */
    uint8_t profileSubset(void) const;
    /**
     *@brief extract "ecc" out of a Ts_tunsdk_dab_epg. 
     *@returns member "ecc"  Extended County Code 
     */
    uint8_t ecc(void) const;
    /**
     *@brief extract "compressionType" out of a Ts_tunsdk_dab_epg. 
     *@returns member "compressionType"  Type of used compression (0: no compression, 1: GZIP ) 
     */
    uint8_t compressionType(void) const;
    /**
     *@brief  Scope ID 
     *@return reference to const array (declare as "const uint8_t (&scopeId)[TUNSDK_DAB_EPG_SCOPEID_COUNT]")
     */
    const uint8_t (&scopeId(void) const) [TUNSDK_DAB_EPG_SCOPEID_COUNT];
    /**
     *@brief extract "scopeIdLength" out of a Ts_tunsdk_dab_epg. 
     *@returns member "scopeIdLength" length that indicates the number of valid bytes in scopeId
     */
    uint8_t scopeIdLength(void) const;
    /**
     *@brief  Content name of the slide  
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&contentName)[TUNSDK_DAB_EPG_CONTENTNAME_COUNT]")
     */
    const T_tunsdk_utf8 (&contentName(void) const) [TUNSDK_DAB_EPG_CONTENTNAME_COUNT];
    /**
     *@brief dataBuffer containing the raw EPG data 
     *@return reference to const array (declare as "const uint8_t (&rawData)[TUNSDK_DAB_EPG_RAWDATA_COUNT]")
     */
    const uint8_t (&rawData(void) const) [TUNSDK_DAB_EPG_RAWDATA_COUNT];
    /**
     *@brief extract "rawDataLength" out of a Ts_tunsdk_dab_epg. 
     *@returns member "rawDataLength" indicates the number of valid bytes in rawData
     */
    uint32_t rawDataLength(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_dab_epg_Handle(const Ts_tunsdk_dab_epg* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_dab_epg* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_amfmhd_preset.
*/
struct Ts_tunsdk_amfmhd_preset;

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in ps
 */
#define TUNSDK_AMFMHD_PRESET_PS_COUNT (9*4)

/**
 *@brief AMFMHD preset information
 */
struct Ts_tunsdk_amfmhd_preset_Handle
{
    /**
     *@brief extract "amfmhdTunable" out of a Ts_tunsdk_amfmhd_preset. 
     *@returns member "amfmhdTunable"  Structure containing tunable information 
     */
    Ts_tunsdk_amfmhd_tunable_Handle amfmhdTunable(void) const;
    /**
     *@brief  contains the PS 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&ps)[TUNSDK_AMFMHD_PRESET_PS_COUNT]")
     */
    const T_tunsdk_utf8 (&ps(void) const) [TUNSDK_AMFMHD_PRESET_PS_COUNT];
    /**
     *@brief extract "pty" out of a Ts_tunsdk_amfmhd_preset. 
     *@returns member "pty"  indicates the rds program type as last received 
     */
    uint8_t pty(void) const;
    /**
     *@brief extract "hd" out of a Ts_tunsdk_amfmhd_preset. 
     *@returns member "hd"  indicates whether station is a hd station, true: is HD (check out hdData), false: no hd (ignore hdData)
     */
    bool hd(void) const;
    /**
     *@brief extract "hdData" out of a Ts_tunsdk_amfmhd_preset. 
     *@returns member "hdData"  hd related station data goes here in case hd=TRUE (Valid only when Ts_tunsdk_amfmhd_preset.hd=TRUE)
     */
    Ts_tunsdk_amfmhd_station_hd_Handle hdData(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_amfmhd_preset_Handle(const Ts_tunsdk_amfmhd_preset* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_amfmhd_preset* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_dab_preset.
*/
struct Ts_tunsdk_dab_preset;

/**
 *@brief number of bytes encoded as T_tunsdk_char in channelLabel
 */
#define TUNSDK_DAB_PRESET_CHANNELLABEL_COUNT 4

/**
 *@brief DAB preset information
 */
struct Ts_tunsdk_dab_preset_Handle
{
    /**
     *@brief extract "dabTunable" out of a Ts_tunsdk_dab_preset. 
     *@returns member "dabTunable"  Structure containing tunable information   
     */
    Ts_tunsdk_dab_tunable_Handle dabTunable(void) const;
    /**
     *@brief extract "ensembleLabel" out of a Ts_tunsdk_dab_preset. 
     *@returns member "ensembleLabel"  Ensemble label                             
     */
    Ts_tunsdk_dab_station_label_Handle ensembleLabel(void) const;
    /**
     *@brief extract "serviceLabel" out of a Ts_tunsdk_dab_preset. 
     *@returns member "serviceLabel"  Service label / Service-Component label   
     */
    Ts_tunsdk_dab_station_label_Handle serviceLabel(void) const;
    /**
     *@brief  Physical channel-name, such as "5A", "11N"  
     *@return reference to const array (declare as "const T_tunsdk_char (&channelLabel)[TUNSDK_DAB_PRESET_CHANNELLABEL_COUNT]")
     */
    const T_tunsdk_char (&channelLabel(void) const) [TUNSDK_DAB_PRESET_CHANNELLABEL_COUNT];
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_dab_preset_Handle(const Ts_tunsdk_dab_preset* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_dab_preset* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Tu_tunsdk_presetdata.
*/
union Tu_tunsdk_presetdata;

/**
 *@brief contains the preset data information of amfm, dab and drm
 */
union Tu_tunsdk_presetdata_Handle
{
    /**
     *@brief extract "amfm" out of a Tu_tunsdk_presetdata. 
     *@returns member "amfm" amfm preset data
     */
    Ts_tunsdk_amfmhd_preset_Handle amfm(void) const;
    /**
     *@brief extract "dab" out of a Tu_tunsdk_presetdata. 
     *@returns member "dab" dab preset data
     */
    Ts_tunsdk_dab_preset_Handle dab(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Tu_tunsdk_presetdata_Handle(const Tu_tunsdk_presetdata* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Tu_tunsdk_presetdata* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_preset.
*/
struct Ts_tunsdk_preset;

/**
 *@brief contains preset data for amfm, dab
 */
struct Ts_tunsdk_preset_Handle
{
    /**
     *@brief extract "band" out of a Ts_tunsdk_preset. 
     *@returns member "band" Indicates the selected band
     */
    Te_tunsdk_band band(void) const;
    /**
     *@brief extract "presetData" out of a Ts_tunsdk_preset. 
     *@returns member "presetData" the preset data
     */
    Tu_tunsdk_presetdata_Handle presetData(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_preset_Handle(const Ts_tunsdk_preset* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_preset* m_pData; /**<pointer to private data, do not access*/
    
    friend struct Ts_tunsdk_preset_list_Handle; /**<allow use as iterator for that list*/
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_preset_list.
*/
struct Ts_tunsdk_preset_list;

/**
 *@brief number of elements of type Ts_tunsdk_preset in presets. Please use #Ts_tunsdk_preset_list_Handle::presets_Length to get the number of elements at runtime (e.g. new version of the interface has different number of elements)
 */
#define TUNSDK_PRESET_LIST_PRESETS_COUNT 36

/**
 *@brief structure to contain a preset list, potentially of mixed bands
 */
struct Ts_tunsdk_preset_list_Handle
{
    /**
     *@brief extraxt the element at index i out of list presets. presets: the actual preset list data. only the first numberPresetsInList fields may be accessed
     *@param i the index out of which to extract
     *@param handle memory in which to place the (handle to) element
     *@returns true in case an element is now in handle, false if the list boundary was exceeded" 
     */                 
    bool presets_ElementAt(uint32_t i, Ts_tunsdk_preset_Handle& handle) const;
    
    /**
     *@brief get the physical dimensions of list "presets" contained in Ts_tunsdk_preset_list "me". See also #TUNSDK_PRESET_LIST_PRESETS_COUNT
     *@returns the size of the underlying array 
     */
    uint32_t presets_Length(void) const;
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_preset_list_Handle(const Ts_tunsdk_preset_list* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_preset_list* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};


/**
 *@brief Type definition for chipset selection 
 */
typedef enum
{
    TUNSDK_CHIPSET_MERCURY = 0, /**<mercury */
}Te_tunsdk_chipset;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_chipset_toString(Te_tunsdk_chipset value);

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_hdtpeg_packet.
*/
struct Ts_tunsdk_hdtpeg_packet;

/**
 *@brief number of elements of type uint8_t in data
 */
#define TUNSDK_HDTPEG_PACKET_DATA_COUNT 2048

/**
 *@brief one packet of HDTPEG
 */
struct Ts_tunsdk_hdtpeg_packet_Handle
{
    /**
     *@brief extract "dataLength" out of a Ts_tunsdk_hdtpeg_packet. 
     *@returns member "dataLength" length to which the "data" buffer is filled 
     */
    uint32_t dataLength(void) const;
    /**
     *@brief raw data as received from the air 
     *@return reference to const array (declare as "const uint8_t (&data)[TUNSDK_HDTPEG_PACKET_DATA_COUNT]")
     */
    const uint8_t (&data(void) const) [TUNSDK_HDTPEG_PACKET_DATA_COUNT];
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_hdtpeg_packet_Handle(const Ts_tunsdk_hdtpeg_packet* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_hdtpeg_packet* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};


/**
* @brief The state of a HD TPEG channel.
*/
typedef enum
{
    TUNSDK_HDTPEG_STATE_OFF = 0,       /**< default after tuning */
    TUNSDK_HDTPEG_STATE_SEARCHING = 1, /**< channel is active, AF search with current AF list and LM content is in progress */
    TUNSDK_HDTPEG_STATE_BAND_SCAN = 2, /**< channel is active, a band scan is in progress */
    TUNSDK_HDTPEG_STATE_RECEIVING = 3, /**< data reception is in progress */
    TUNSDK_HDTPEG_STATE_INVALID = 4,   /**< requested hdtpeg service is not supported */
}Te_tunsdk_hdtpeg_channel_state;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_hdtpeg_channel_state_toString(Te_tunsdk_hdtpeg_channel_state value);


/**
* @brief Identifies HD TPEG services
*/
typedef enum
{
    TUNSDK_HDTPEG_SERVICE_NONE = 0,    /**< NONE */
    TUNSDK_HDTPEG_SERVICE_HERE = 1,    /**< HERE */
    TUNSDK_HDTPEG_SERVICE_INVALID = 3, /**< INVALID, do not use */
}Te_tunsdk_hdtpeg_service;

/**
*@brief get a string constant for the enum value passed
*@param value the calue to convert
*@return the string representation of that enum value
*/
const T_tunsdk_char* Te_tunsdk_hdtpeg_service_toString(Te_tunsdk_hdtpeg_service value);

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_hd_emergency_alert.
*/
struct Ts_tunsdk_hd_emergency_alert;

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in hdStationName
 */
#define TUNSDK_HD_EMERGENCY_ALERT_HDSTATIONNAME_COUNT (17*4)

/**
 *@brief number of bytes encoded as T_tunsdk_utf8 in emergencyMessage
 */
#define TUNSDK_HD_EMERGENCY_ALERT_EMERGENCYMESSAGE_COUNT (417*4)

/**
 * @brief definition for hd emergency alert notification 
 */
struct Ts_tunsdk_hd_emergency_alert_Handle
{
    /**
     *@brief extract "freqKHz" out of a Ts_tunsdk_hd_emergency_alert. 
     *@returns member "freqKHz" the frequency this alert was received on
     */
    uint32_t freqKHz(void) const;
    /**
     *@brief station name of the station 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&hdStationName)[TUNSDK_HD_EMERGENCY_ALERT_HDSTATIONNAME_COUNT]")
     */
    const T_tunsdk_utf8 (&hdStationName(void) const) [TUNSDK_HD_EMERGENCY_ALERT_HDSTATIONNAME_COUNT];
    /**
     *@brief  Emergency message string 
     *@return reference to const array (declare as "const T_tunsdk_utf8 (&emergencyMessage)[TUNSDK_HD_EMERGENCY_ALERT_EMERGENCYMESSAGE_COUNT]")
     */
    const T_tunsdk_utf8 (&emergencyMessage(void) const) [TUNSDK_HD_EMERGENCY_ALERT_EMERGENCYMESSAGE_COUNT];
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_hd_emergency_alert_Handle(const Ts_tunsdk_hd_emergency_alert* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_hd_emergency_alert* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

/**
*@brief opaque type that gives access to members contained in Ts_tunsdk_image.
*/
struct Ts_tunsdk_image;

/**
 *@brief number of elements of type uint8_t in buffer
 */
#define TUNSDK_IMAGE_BUFFER_COUNT 80240

/**
 * @brief An image received from TUNSDK 
 */
struct Ts_tunsdk_image_Handle
{
    /**
     *@brief extract "size" out of a Ts_tunsdk_image. 
     *@returns member "size" size of the image 
     */
    uint32_t size(void) const;
    /**
     *@brief memory to hold the image  
     *@return reference to const array (declare as "const uint8_t (&buffer)[TUNSDK_IMAGE_BUFFER_COUNT]")
     */
    const uint8_t (&buffer(void) const) [TUNSDK_IMAGE_BUFFER_COUNT];
    
    /**
     *@brief constructor
     *@param pData pointer to the actual data to be represented by this object
     */
    explicit Ts_tunsdk_image_Handle(const Ts_tunsdk_image* pData) : m_pData(pData){}
    
    /**@cond PRIVATE*/
    private:
    const Ts_tunsdk_image* m_pData; /**<pointer to private data, do not access*/
    
    /**@endcond*/
     
};

#endif /* TUNSDK_TYPES_H_ */

/*=============================================================================
    end of file
=============================================================================*/

